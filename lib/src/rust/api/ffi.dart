// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'modules/media_player.dart';
import 'modules/metronome.dart';
import 'modules/metronome_rhythm.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<void> initAudio() => RustLib.instance.api.crateApiFfiInitAudio();

Future<double?> tunerGetFrequency() => RustLib.instance.api.crateApiFfiTunerGetFrequency();

Future<bool> tunerStart() => RustLib.instance.api.crateApiFfiTunerStart();

Future<bool> tunerStop() => RustLib.instance.api.crateApiFfiTunerStop();

Future<bool> generatorStart() => RustLib.instance.api.crateApiFfiGeneratorStart();

Future<bool> generatorStop() => RustLib.instance.api.crateApiFfiGeneratorStop();

Future<bool> generatorNoteOn({required double newFreq}) =>
    RustLib.instance.api.crateApiFfiGeneratorNoteOn(newFreq: newFreq);

Future<bool> generatorNoteOff() => RustLib.instance.api.crateApiFfiGeneratorNoteOff();

Future<bool> pianoSetConcertPitch({required double newConcertPitch}) =>
    RustLib.instance.api.crateApiFfiPianoSetConcertPitch(newConcertPitch: newConcertPitch);

Future<bool> mediaPlayerLoadWav({required int id, required String wavFilePath}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerLoadWav(id: id, wavFilePath: wavFilePath);

Future<bool> mediaPlayerStart({required int id}) => RustLib.instance.api.crateApiFfiMediaPlayerStart(id: id);

Future<bool> mediaPlayerStop({required int id}) => RustLib.instance.api.crateApiFfiMediaPlayerStop(id: id);

Future<bool> mediaPlayerStartRecording() => RustLib.instance.api.crateApiFfiMediaPlayerStartRecording();

Future<bool> mediaPlayerStopRecording() => RustLib.instance.api.crateApiFfiMediaPlayerStopRecording();

Future<Float64List> mediaPlayerGetRecordingSamples() =>
    RustLib.instance.api.crateApiFfiMediaPlayerGetRecordingSamples();

Future<bool> mediaPlayerSetPitchSemitones({required int id, required double pitchSemitones}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetPitchSemitones(id: id, pitchSemitones: pitchSemitones);

Future<bool> mediaPlayerSetSpeedFactor({required int id, required double speedFactor}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetSpeedFactor(id: id, speedFactor: speedFactor);

Future<void> mediaPlayerSetTrim({required int id, required double startFactor, required double endFactor}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetTrim(id: id, startFactor: startFactor, endFactor: endFactor);

Future<Float32List> mediaPlayerGetRms({required int id, required int nBins}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerGetRms(id: id, nBins: nBins);

Future<void> mediaPlayerSetLoop({required int id, required bool looping}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetLoop(id: id, looping: looping);

Future<MediaPlayerState?> mediaPlayerGetState({required int id}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerGetState(id: id);

Future<bool> mediaPlayerSetPlaybackPosFactor({required int id, required double posFactor}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetPlaybackPosFactor(id: id, posFactor: posFactor);

Future<bool> mediaPlayerSetVolume({required int id, required double volume}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerSetVolume(id: id, volume: volume);

Future<void> mediaPlayerDestroyInstance({required int id}) =>
    RustLib.instance.api.crateApiFfiMediaPlayerDestroyInstance(id: id);

Future<bool> mediaPlayerRenderMidiToWav({
  required String midiPath,
  required String soundFontPath,
  required String wavOutPath,
  required int sampleRate,
  required double gain,
}) => RustLib.instance.api.crateApiFfiMediaPlayerRenderMidiToWav(
  midiPath: midiPath,
  soundFontPath: soundFontPath,
  wavOutPath: wavOutPath,
  sampleRate: sampleRate,
  gain: gain,
);

Future<bool> metronomeStart() => RustLib.instance.api.crateApiFfiMetronomeStart();

Future<bool> metronomeStop() => RustLib.instance.api.crateApiFfiMetronomeStop();

Future<bool> metronomeSetBpm({required double bpm}) => RustLib.instance.api.crateApiFfiMetronomeSetBpm(bpm: bpm);

Future<bool> metronomeLoadFile({required BeatSound beatType, required String wavFilePath}) =>
    RustLib.instance.api.crateApiFfiMetronomeLoadFile(beatType: beatType, wavFilePath: wavFilePath);

Future<bool> metronomeSetRhythm({required List<MetroBar> bars, required List<MetroBar> bars2}) =>
    RustLib.instance.api.crateApiFfiMetronomeSetRhythm(bars: bars, bars2: bars2);

Future<BeatHappenedEvent?> metronomePollBeatEventHappened() =>
    RustLib.instance.api.crateApiFfiMetronomePollBeatEventHappened();

Future<bool> metronomeSetMuted({required bool muted}) =>
    RustLib.instance.api.crateApiFfiMetronomeSetMuted(muted: muted);

Future<bool> metronomeSetBeatMuteChance({required double muteChance}) =>
    RustLib.instance.api.crateApiFfiMetronomeSetBeatMuteChance(muteChance: muteChance);

Future<bool> metronomeSetVolume({required double volume}) =>
    RustLib.instance.api.crateApiFfiMetronomeSetVolume(volume: volume);

Future<bool> pianoSetup({required String soundFontPath}) =>
    RustLib.instance.api.crateApiFfiPianoSetup(soundFontPath: soundFontPath);

Future<bool> pianoStart() => RustLib.instance.api.crateApiFfiPianoStart();

Future<bool> pianoStop() => RustLib.instance.api.crateApiFfiPianoStop();

Future<bool> pianoNoteOn({required int note}) => RustLib.instance.api.crateApiFfiPianoNoteOn(note: note);

Future<bool> pianoNoteOff({required int note}) => RustLib.instance.api.crateApiFfiPianoNoteOff(note: note);

Future<bool> pianoSetVolume({required double volume}) => RustLib.instance.api.crateApiFfiPianoSetVolume(volume: volume);

Future<int> getSampleRate() => RustLib.instance.api.crateApiFfiGetSampleRate();

Future<bool> debugTestFunction() => RustLib.instance.api.crateApiFfiDebugTestFunction();
