// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/ffi.dart';
import 'api/modules/media_player.dart';
import 'api/modules/metronome.dart';
import 'api/modules/metronome_rhythm.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor => RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor => RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 886734281;

  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
    stem: 'rust_lib_tiomusic',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<bool> crateApiFfiDebugTestFunction();

  Future<bool> crateApiFfiGeneratorNoteOff();

  Future<bool> crateApiFfiGeneratorNoteOn({required double newFreq});

  Future<bool> crateApiFfiGeneratorStart();

  Future<bool> crateApiFfiGeneratorStop();

  Future<int> crateApiFfiGetSampleRate();

  Future<void> crateApiFfiInitAudio();

  Future<void> crateApiSimpleInitRustDefaultsManually();

  Future<Float64List> crateApiFfiMediaPlayerGetRecordingSamples();

  Future<Float32List> crateApiFfiMediaPlayerGetRms({required int nBins});

  Future<Float32List> crateApiFfiMediaPlayerGetRmsWithId({required String playerId, required int nBins});

  Future<MediaPlayerState?> crateApiFfiMediaPlayerGetState();

  Future<MediaPlayerState?> crateApiFfiMediaPlayerGetStateWithId({required String playerId});

  Future<bool> crateApiFfiMediaPlayerLoadWav({required String wavFilePath});

  Future<bool> crateApiFfiMediaPlayerLoadWavWithId({required String playerId, required String wavFilePath});

  Future<void> crateApiFfiMediaPlayerSetLoop({required bool looping});

  Future<void> crateApiFfiMediaPlayerSetLoopWithId({required String playerId, required bool looping});

  Future<bool> crateApiFfiMediaPlayerSetPitchSemitones({required double pitchSemitones});

  Future<bool> crateApiFfiMediaPlayerSetPitchSemitonesWithId({
    required String playerId,
    required double pitchSemitones,
  });

  Future<bool> crateApiFfiMediaPlayerSetPlaybackPosFactor({required double posFactor});

  Future<bool> crateApiFfiMediaPlayerSetPosFactorWithId({required String playerId, required double posFactor});

  Future<bool> crateApiFfiMediaPlayerSetSpeedFactor({required double speedFactor});

  Future<bool> crateApiFfiMediaPlayerSetSpeedFactorWithId({required String playerId, required double speedFactor});

  Future<void> crateApiFfiMediaPlayerSetTrim({required double startFactor, required double endFactor});

  Future<void> crateApiFfiMediaPlayerSetTrimByFactorWithId({
    required String playerId,
    required double startFactor,
    required double endFactor,
  });

  Future<bool> crateApiFfiMediaPlayerSetVolume({required double volume});

  Future<bool> crateApiFfiMediaPlayerSetVolumeWithId({required String playerId, required double volume});

  Future<bool> crateApiFfiMediaPlayerStart();

  Future<bool> crateApiFfiMediaPlayerStartRecording();

  Future<bool> crateApiFfiMediaPlayerStartWithId({required String playerId});

  Future<bool> crateApiFfiMediaPlayerStop();

  Future<bool> crateApiFfiMediaPlayerStopRecording();

  Future<bool> crateApiFfiMediaPlayerStopWithId({required String playerId});

  Future<bool> crateApiFfiMetronomeLoadFile({required BeatSound beatType, required String wavFilePath});

  Future<BeatHappenedEvent?> crateApiFfiMetronomePollBeatEventHappened();

  Future<bool> crateApiFfiMetronomeSetBeatMuteChance({required double muteChance});

  Future<bool> crateApiFfiMetronomeSetBpm({required double bpm});

  Future<bool> crateApiFfiMetronomeSetMuted({required bool muted});

  Future<bool> crateApiFfiMetronomeSetRhythm({required List<MetroBar> bars, required List<MetroBar> bars2});

  Future<bool> crateApiFfiMetronomeSetVolume({required double volume});

  Future<bool> crateApiFfiMetronomeStart();

  Future<bool> crateApiFfiMetronomeStop();

  Future<bool> crateApiFfiPianoNoteOff({required int note});

  Future<bool> crateApiFfiPianoNoteOn({required int note});

  Future<bool> crateApiFfiPianoSetConcertPitch({required double newConcertPitch});

  Future<bool> crateApiFfiPianoSetVolume({required double volume});

  Future<bool> crateApiFfiPianoSetup({required String soundFontPath});

  Future<bool> crateApiFfiPianoStart();

  Future<bool> crateApiFfiPianoStop();

  Future<double?> crateApiFfiTunerGetFrequency();

  Future<bool> crateApiFfiTunerStart();

  Future<bool> crateApiFfiTunerStop();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<bool> crateApiFfiDebugTestFunction() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiDebugTestFunctionConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiDebugTestFunctionConstMeta =>
      const TaskConstMeta(debugName: "debug_test_function", argNames: []);

  @override
  Future<bool> crateApiFfiGeneratorNoteOff() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiGeneratorNoteOffConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiGeneratorNoteOffConstMeta =>
      const TaskConstMeta(debugName: "generator_note_off", argNames: []);

  @override
  Future<bool> crateApiFfiGeneratorNoteOn({required double newFreq}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(newFreq, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiGeneratorNoteOnConstMeta,
        argValues: [newFreq],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiGeneratorNoteOnConstMeta =>
      const TaskConstMeta(debugName: "generator_note_on", argNames: ["newFreq"]);

  @override
  Future<bool> crateApiFfiGeneratorStart() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiGeneratorStartConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiGeneratorStartConstMeta =>
      const TaskConstMeta(debugName: "generator_start", argNames: []);

  @override
  Future<bool> crateApiFfiGeneratorStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiGeneratorStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiGeneratorStopConstMeta =>
      const TaskConstMeta(debugName: "generator_stop", argNames: []);

  @override
  Future<int> crateApiFfiGetSampleRate() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_CastedPrimitive_usize, decodeErrorData: null),
        constMeta: kCrateApiFfiGetSampleRateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiGetSampleRateConstMeta =>
      const TaskConstMeta(debugName: "get_sample_rate", argNames: []);

  @override
  Future<void> crateApiFfiInitAudio() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiFfiInitAudioConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiInitAudioConstMeta => const TaskConstMeta(debugName: "init_audio", argNames: []);

  @override
  Future<void> crateApiSimpleInitRustDefaultsManually() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiSimpleInitRustDefaultsManuallyConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleInitRustDefaultsManuallyConstMeta =>
      const TaskConstMeta(debugName: "init_rust_defaults_manually", argNames: []);

  @override
  Future<Float64List> crateApiFfiMediaPlayerGetRecordingSamples() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_list_prim_f_64_strict, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerGetRecordingSamplesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerGetRecordingSamplesConstMeta =>
      const TaskConstMeta(debugName: "media_player_get_recording_samples", argNames: []);

  @override
  Future<Float32List> crateApiFfiMediaPlayerGetRms({required int nBins}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_CastedPrimitive_usize(nBins, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_list_prim_f_32_strict, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerGetRmsConstMeta,
        argValues: [nBins],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerGetRmsConstMeta =>
      const TaskConstMeta(debugName: "media_player_get_rms", argNames: ["nBins"]);

  @override
  Future<Float32List> crateApiFfiMediaPlayerGetRmsWithId({required String playerId, required int nBins}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_i_32(nBins, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_list_prim_f_32_strict, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerGetRmsWithIdConstMeta,
        argValues: [playerId, nBins],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerGetRmsWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_get_rms_with_id", argNames: ["playerId", "nBins"]);

  @override
  Future<MediaPlayerState?> crateApiFfiMediaPlayerGetState() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_opt_box_autoadd_media_player_state, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerGetStateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerGetStateConstMeta =>
      const TaskConstMeta(debugName: "media_player_get_state", argNames: []);

  @override
  Future<MediaPlayerState?> crateApiFfiMediaPlayerGetStateWithId({required String playerId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_opt_box_autoadd_media_player_state, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerGetStateWithIdConstMeta,
        argValues: [playerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerGetStateWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_get_state_with_id", argNames: ["playerId"]);

  @override
  Future<bool> crateApiFfiMediaPlayerLoadWav({required String wavFilePath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(wavFilePath, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerLoadWavConstMeta,
        argValues: [wavFilePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerLoadWavConstMeta =>
      const TaskConstMeta(debugName: "media_player_load_wav", argNames: ["wavFilePath"]);

  @override
  Future<bool> crateApiFfiMediaPlayerLoadWavWithId({required String playerId, required String wavFilePath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_String(wavFilePath, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerLoadWavWithIdConstMeta,
        argValues: [playerId, wavFilePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerLoadWavWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_load_wav_with_id", argNames: ["playerId", "wavFilePath"]);

  @override
  Future<void> crateApiFfiMediaPlayerSetLoop({required bool looping}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(looping, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetLoopConstMeta,
        argValues: [looping],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetLoopConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_loop", argNames: ["looping"]);

  @override
  Future<void> crateApiFfiMediaPlayerSetLoopWithId({required String playerId, required bool looping}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_bool(looping, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetLoopWithIdConstMeta,
        argValues: [playerId, looping],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetLoopWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_loop_with_id", argNames: ["playerId", "looping"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetPitchSemitones({required double pitchSemitones}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(pitchSemitones, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetPitchSemitonesConstMeta,
        argValues: [pitchSemitones],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetPitchSemitonesConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_pitch_semitones", argNames: ["pitchSemitones"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetPitchSemitonesWithId({
    required String playerId,
    required double pitchSemitones,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_f_32(pitchSemitones, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetPitchSemitonesWithIdConstMeta,
        argValues: [playerId, pitchSemitones],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetPitchSemitonesWithIdConstMeta => const TaskConstMeta(
    debugName: "media_player_set_pitch_semitones_with_id",
    argNames: ["playerId", "pitchSemitones"],
  );

  @override
  Future<bool> crateApiFfiMediaPlayerSetPlaybackPosFactor({required double posFactor}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(posFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetPlaybackPosFactorConstMeta,
        argValues: [posFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetPlaybackPosFactorConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_playback_pos_factor", argNames: ["posFactor"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetPosFactorWithId({required String playerId, required double posFactor}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_f_32(posFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetPosFactorWithIdConstMeta,
        argValues: [playerId, posFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetPosFactorWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_pos_factor_with_id", argNames: ["playerId", "posFactor"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetSpeedFactor({required double speedFactor}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(speedFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetSpeedFactorConstMeta,
        argValues: [speedFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetSpeedFactorConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_speed_factor", argNames: ["speedFactor"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetSpeedFactorWithId({required String playerId, required double speedFactor}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_f_32(speedFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetSpeedFactorWithIdConstMeta,
        argValues: [playerId, speedFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetSpeedFactorWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_speed_factor_with_id", argNames: ["playerId", "speedFactor"]);

  @override
  Future<void> crateApiFfiMediaPlayerSetTrim({required double startFactor, required double endFactor}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(startFactor, serializer);
          sse_encode_f_32(endFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetTrimConstMeta,
        argValues: [startFactor, endFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetTrimConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_trim", argNames: ["startFactor", "endFactor"]);

  @override
  Future<void> crateApiFfiMediaPlayerSetTrimByFactorWithId({
    required String playerId,
    required double startFactor,
    required double endFactor,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_f_32(startFactor, serializer);
          sse_encode_f_32(endFactor, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_unit, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetTrimByFactorWithIdConstMeta,
        argValues: [playerId, startFactor, endFactor],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetTrimByFactorWithIdConstMeta => const TaskConstMeta(
    debugName: "media_player_set_trim_by_factor_with_id",
    argNames: ["playerId", "startFactor", "endFactor"],
  );

  @override
  Future<bool> crateApiFfiMediaPlayerSetVolume({required double volume}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(volume, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetVolumeConstMeta,
        argValues: [volume],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetVolumeConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_volume", argNames: ["volume"]);

  @override
  Future<bool> crateApiFfiMediaPlayerSetVolumeWithId({required String playerId, required double volume}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          sse_encode_f_32(volume, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerSetVolumeWithIdConstMeta,
        argValues: [playerId, volume],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerSetVolumeWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_set_volume_with_id", argNames: ["playerId", "volume"]);

  @override
  Future<bool> crateApiFfiMediaPlayerStart() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStartConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStartConstMeta =>
      const TaskConstMeta(debugName: "media_player_start", argNames: []);

  @override
  Future<bool> crateApiFfiMediaPlayerStartRecording() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStartRecordingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStartRecordingConstMeta =>
      const TaskConstMeta(debugName: "media_player_start_recording", argNames: []);

  @override
  Future<bool> crateApiFfiMediaPlayerStartWithId({required String playerId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStartWithIdConstMeta,
        argValues: [playerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStartWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_start_with_id", argNames: ["playerId"]);

  @override
  Future<bool> crateApiFfiMediaPlayerStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStopConstMeta =>
      const TaskConstMeta(debugName: "media_player_stop", argNames: []);

  @override
  Future<bool> crateApiFfiMediaPlayerStopRecording() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStopRecordingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStopRecordingConstMeta =>
      const TaskConstMeta(debugName: "media_player_stop_recording", argNames: []);

  @override
  Future<bool> crateApiFfiMediaPlayerStopWithId({required String playerId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(playerId, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMediaPlayerStopWithIdConstMeta,
        argValues: [playerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMediaPlayerStopWithIdConstMeta =>
      const TaskConstMeta(debugName: "media_player_stop_with_id", argNames: ["playerId"]);

  @override
  Future<bool> crateApiFfiMetronomeLoadFile({required BeatSound beatType, required String wavFilePath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_beat_sound(beatType, serializer);
          sse_encode_String(wavFilePath, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeLoadFileConstMeta,
        argValues: [beatType, wavFilePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeLoadFileConstMeta =>
      const TaskConstMeta(debugName: "metronome_load_file", argNames: ["beatType", "wavFilePath"]);

  @override
  Future<BeatHappenedEvent?> crateApiFfiMetronomePollBeatEventHappened() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_opt_box_autoadd_beat_happened_event, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomePollBeatEventHappenedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomePollBeatEventHappenedConstMeta =>
      const TaskConstMeta(debugName: "metronome_poll_beat_event_happened", argNames: []);

  @override
  Future<bool> crateApiFfiMetronomeSetBeatMuteChance({required double muteChance}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(muteChance, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeSetBeatMuteChanceConstMeta,
        argValues: [muteChance],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeSetBeatMuteChanceConstMeta =>
      const TaskConstMeta(debugName: "metronome_set_beat_mute_chance", argNames: ["muteChance"]);

  @override
  Future<bool> crateApiFfiMetronomeSetBpm({required double bpm}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(bpm, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeSetBpmConstMeta,
        argValues: [bpm],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeSetBpmConstMeta =>
      const TaskConstMeta(debugName: "metronome_set_bpm", argNames: ["bpm"]);

  @override
  Future<bool> crateApiFfiMetronomeSetMuted({required bool muted}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_bool(muted, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeSetMutedConstMeta,
        argValues: [muted],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeSetMutedConstMeta =>
      const TaskConstMeta(debugName: "metronome_set_muted", argNames: ["muted"]);

  @override
  Future<bool> crateApiFfiMetronomeSetRhythm({required List<MetroBar> bars, required List<MetroBar> bars2}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_metro_bar(bars, serializer);
          sse_encode_list_metro_bar(bars2, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeSetRhythmConstMeta,
        argValues: [bars, bars2],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeSetRhythmConstMeta =>
      const TaskConstMeta(debugName: "metronome_set_rhythm", argNames: ["bars", "bars2"]);

  @override
  Future<bool> crateApiFfiMetronomeSetVolume({required double volume}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(volume, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeSetVolumeConstMeta,
        argValues: [volume],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeSetVolumeConstMeta =>
      const TaskConstMeta(debugName: "metronome_set_volume", argNames: ["volume"]);

  @override
  Future<bool> crateApiFfiMetronomeStart() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeStartConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeStartConstMeta =>
      const TaskConstMeta(debugName: "metronome_start", argNames: []);

  @override
  Future<bool> crateApiFfiMetronomeStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiMetronomeStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiMetronomeStopConstMeta =>
      const TaskConstMeta(debugName: "metronome_stop", argNames: []);

  @override
  Future<bool> crateApiFfiPianoNoteOff({required int note}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(note, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoNoteOffConstMeta,
        argValues: [note],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoNoteOffConstMeta =>
      const TaskConstMeta(debugName: "piano_note_off", argNames: ["note"]);

  @override
  Future<bool> crateApiFfiPianoNoteOn({required int note}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(note, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoNoteOnConstMeta,
        argValues: [note],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoNoteOnConstMeta =>
      const TaskConstMeta(debugName: "piano_note_on", argNames: ["note"]);

  @override
  Future<bool> crateApiFfiPianoSetConcertPitch({required double newConcertPitch}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(newConcertPitch, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoSetConcertPitchConstMeta,
        argValues: [newConcertPitch],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoSetConcertPitchConstMeta =>
      const TaskConstMeta(debugName: "piano_set_concert_pitch", argNames: ["newConcertPitch"]);

  @override
  Future<bool> crateApiFfiPianoSetVolume({required double volume}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_f_32(volume, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoSetVolumeConstMeta,
        argValues: [volume],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoSetVolumeConstMeta =>
      const TaskConstMeta(debugName: "piano_set_volume", argNames: ["volume"]);

  @override
  Future<bool> crateApiFfiPianoSetup({required String soundFontPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(soundFontPath, serializer);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoSetupConstMeta,
        argValues: [soundFontPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoSetupConstMeta =>
      const TaskConstMeta(debugName: "piano_setup", argNames: ["soundFontPath"]);

  @override
  Future<bool> crateApiFfiPianoStart() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoStartConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoStartConstMeta => const TaskConstMeta(debugName: "piano_start", argNames: []);

  @override
  Future<bool> crateApiFfiPianoStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiPianoStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiPianoStopConstMeta => const TaskConstMeta(debugName: "piano_stop", argNames: []);

  @override
  Future<double?> crateApiFfiTunerGetFrequency() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_opt_box_autoadd_f_32, decodeErrorData: null),
        constMeta: kCrateApiFfiTunerGetFrequencyConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiTunerGetFrequencyConstMeta =>
      const TaskConstMeta(debugName: "tuner_get_frequency", argNames: []);

  @override
  Future<bool> crateApiFfiTunerStart() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiTunerStartConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiTunerStartConstMeta => const TaskConstMeta(debugName: "tuner_start", argNames: []);

  @override
  Future<bool> crateApiFfiTunerStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52, port: port_);
        },
        codec: SseCodec(decodeSuccessData: sse_decode_bool, decodeErrorData: null),
        constMeta: kCrateApiFfiTunerStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFfiTunerStopConstMeta => const TaskConstMeta(debugName: "tuner_stop", argNames: []);

  @protected
  int dco_decode_CastedPrimitive_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('Not implemented in this codec, please use the other one');
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  BeatHappenedEvent dco_decode_beat_happened_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return BeatHappenedEvent(
      millisecondsBeforeStart: dco_decode_i_32(arr[0]),
      isRandomMute: dco_decode_bool(arr[1]),
      barIndex: dco_decode_i_32(arr[2]),
      isPoly: dco_decode_bool(arr[3]),
      isSecondary: dco_decode_bool(arr[4]),
      beatIndex: dco_decode_i_32(arr[5]),
    );
  }

  @protected
  BeatSound dco_decode_beat_sound(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BeatSound.values[raw as int];
  }

  @protected
  BeatType dco_decode_beat_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BeatType.values[raw as int];
  }

  @protected
  BeatTypePoly dco_decode_beat_type_poly(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BeatTypePoly.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BeatHappenedEvent dco_decode_box_autoadd_beat_happened_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_beat_happened_event(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  MediaPlayerState dco_decode_box_autoadd_media_player_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_player_state(raw);
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<BeatType> dco_decode_list_beat_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_beat_type).toList();
  }

  @protected
  List<BeatTypePoly> dco_decode_list_beat_type_poly(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_beat_type_poly).toList();
  }

  @protected
  List<MetroBar> dco_decode_list_metro_bar(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_metro_bar).toList();
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  Float64List dco_decode_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float64List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  MediaPlayerState dco_decode_media_player_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6) throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return MediaPlayerState(
      playing: dco_decode_bool(arr[0]),
      playbackPositionFactor: dco_decode_f_32(arr[1]),
      totalLengthSeconds: dco_decode_f_32(arr[2]),
      looping: dco_decode_bool(arr[3]),
      trimStartFactor: dco_decode_f_32(arr[4]),
      trimEndFactor: dco_decode_f_32(arr[5]),
    );
  }

  @protected
  MetroBar dco_decode_metro_bar(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MetroBar(
      id: dco_decode_i_32(arr[0]),
      beats: dco_decode_list_beat_type(arr[1]),
      polyBeats: dco_decode_list_beat_type_poly(arr[2]),
      beatLen: dco_decode_f_32(arr[3]),
    );
  }

  @protected
  BeatHappenedEvent? dco_decode_opt_box_autoadd_beat_happened_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_beat_happened_event(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  MediaPlayerState? dco_decode_opt_box_autoadd_media_player_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_media_player_state(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int sse_decode_CastedPrimitive_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_usize(deserializer);
    return inner.toInt();
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  BeatHappenedEvent sse_decode_beat_happened_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_millisecondsBeforeStart = sse_decode_i_32(deserializer);
    var var_isRandomMute = sse_decode_bool(deserializer);
    var var_barIndex = sse_decode_i_32(deserializer);
    var var_isPoly = sse_decode_bool(deserializer);
    var var_isSecondary = sse_decode_bool(deserializer);
    var var_beatIndex = sse_decode_i_32(deserializer);
    return BeatHappenedEvent(
      millisecondsBeforeStart: var_millisecondsBeforeStart,
      isRandomMute: var_isRandomMute,
      barIndex: var_barIndex,
      isPoly: var_isPoly,
      isSecondary: var_isSecondary,
      beatIndex: var_beatIndex,
    );
  }

  @protected
  BeatSound sse_decode_beat_sound(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BeatSound.values[inner];
  }

  @protected
  BeatType sse_decode_beat_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BeatType.values[inner];
  }

  @protected
  BeatTypePoly sse_decode_beat_type_poly(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BeatTypePoly.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BeatHappenedEvent sse_decode_box_autoadd_beat_happened_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_beat_happened_event(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  MediaPlayerState sse_decode_box_autoadd_media_player_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_player_state(deserializer));
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<BeatType> sse_decode_list_beat_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BeatType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_beat_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<BeatTypePoly> sse_decode_list_beat_type_poly(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BeatTypePoly>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_beat_type_poly(deserializer));
    }
    return ans_;
  }

  @protected
  List<MetroBar> sse_decode_list_metro_bar(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MetroBar>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_metro_bar(deserializer));
    }
    return ans_;
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  MediaPlayerState sse_decode_media_player_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_playing = sse_decode_bool(deserializer);
    var var_playbackPositionFactor = sse_decode_f_32(deserializer);
    var var_totalLengthSeconds = sse_decode_f_32(deserializer);
    var var_looping = sse_decode_bool(deserializer);
    var var_trimStartFactor = sse_decode_f_32(deserializer);
    var var_trimEndFactor = sse_decode_f_32(deserializer);
    return MediaPlayerState(
      playing: var_playing,
      playbackPositionFactor: var_playbackPositionFactor,
      totalLengthSeconds: var_totalLengthSeconds,
      looping: var_looping,
      trimStartFactor: var_trimStartFactor,
      trimEndFactor: var_trimEndFactor,
    );
  }

  @protected
  MetroBar sse_decode_metro_bar(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_32(deserializer);
    var var_beats = sse_decode_list_beat_type(deserializer);
    var var_polyBeats = sse_decode_list_beat_type_poly(deserializer);
    var var_beatLen = sse_decode_f_32(deserializer);
    return MetroBar(id: var_id, beats: var_beats, polyBeats: var_polyBeats, beatLen: var_beatLen);
  }

  @protected
  BeatHappenedEvent? sse_decode_opt_box_autoadd_beat_happened_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_beat_happened_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MediaPlayerState? sse_decode_opt_box_autoadd_media_player_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_media_player_state(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_CastedPrimitive_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(sseEncodeCastedPrimitiveU64(self), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_beat_happened_event(BeatHappenedEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.millisecondsBeforeStart, serializer);
    sse_encode_bool(self.isRandomMute, serializer);
    sse_encode_i_32(self.barIndex, serializer);
    sse_encode_bool(self.isPoly, serializer);
    sse_encode_bool(self.isSecondary, serializer);
    sse_encode_i_32(self.beatIndex, serializer);
  }

  @protected
  void sse_encode_beat_sound(BeatSound self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_beat_type(BeatType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_beat_type_poly(BeatTypePoly self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_beat_happened_event(BeatHappenedEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_beat_happened_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_player_state(MediaPlayerState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_player_state(self, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_beat_type(List<BeatType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_beat_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_beat_type_poly(List<BeatTypePoly> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_beat_type_poly(item, serializer);
    }
  }

  @protected
  void sse_encode_list_metro_bar(List<MetroBar> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_metro_bar(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_strict(Float32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_f_64_strict(Float64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_media_player_state(MediaPlayerState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.playing, serializer);
    sse_encode_f_32(self.playbackPositionFactor, serializer);
    sse_encode_f_32(self.totalLengthSeconds, serializer);
    sse_encode_bool(self.looping, serializer);
    sse_encode_f_32(self.trimStartFactor, serializer);
    sse_encode_f_32(self.trimEndFactor, serializer);
  }

  @protected
  void sse_encode_metro_bar(MetroBar self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.id, serializer);
    sse_encode_list_beat_type(self.beats, serializer);
    sse_encode_list_beat_type_poly(self.polyBeats, serializer);
    sse_encode_f_32(self.beatLen, serializer);
  }

  @protected
  void sse_encode_opt_box_autoadd_beat_happened_event(BeatHappenedEvent? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_beat_happened_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_media_player_state(MediaPlayerState? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_media_player_state(self, serializer);
    }
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
